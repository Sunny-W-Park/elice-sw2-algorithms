def solution(n):
    # 처음 dp 세팅- n이 5000까지여서 5001까지
    Num = 1000000007
    dp = [0]*5001
    # 블록이 없다는 것은 하나의 경우의 수이고, 4일 경우를 위해 dp[0]을 1로 할당
    dp[0] = 1
    # dp[2] 는 ||   -  =
    #         -   ||  -     총 3종류
    dp[2] = 3
    # 가로의 길이가 홀수 일 경우, 총 넓이는 3 * 홀수이므로 홀수가 나온다
    # 총 넓이가 홀수이므로, 가로의 길이가 짝수인 경우만 고려
    for i in range(4, n+1, 2):  # dp(4)부터 dp(n) 까지를 짝수만 계산
        # 직전 case는 그 직전 dp에 dp[2]의 경우의 수인 3을 곱하여 더한다.
        dp[i] += dp[i-2]*3 % Num
        # 이외로 dp[4]에 특이 case가 2개 있듯이, dp[i-4] 부터 dp[0] 까지 특이 case가 2개씩 존재함.
        # (세로+가로*2*x+세로 형식)
        # dp(i)에게는 dp[i-4]부터 dp[0]까지, 2를 곱해주어야함
        #예: dp[8]= dp[6]*3 + dp[4]*2 +dp[2]*2+ dp[0]*2
        for j in range(0, i-3, 2):  # dp[0] 부터 dp[n-4]까지 짝수만 계산
            dp[i] += (dp[j]*2) % Num
        dp[i] = dp[i] % Num  # 최종값을 더했을 경우 100000007를 넘을 가능성이 있어서 다시 나머지 계산
    return dp[n]
